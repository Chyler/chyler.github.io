---
layout: post
title:  "不再害怕指针"
date:   2016-05-16 00:00:00
categories: ["base"]
author: "Chyler"
---



**1.指针的类型【指针本身所具有的类型】**

把指针声明语句里的指针名字去掉，剩下的部分是这个指针的类型

**2.指针所指向的类型【通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待】**

把指针声明语句中的指针名字和名字左边的 * 去掉，剩下的就是指针所指向的内容

**3.指针的值（指针所指向的内存区或地址）**

指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为sizeof(指针所指向的类型)的一片区域。

**4.指针本身所占据的内存区**


-------
-------

**指针运算**

指针ptr加减一个整数n之后，结果得到新的指针，新指针和原来的指针类型相同，新指针所指向的类型和原来的指针所指向的类型也相同，新指针的值比旧指针的值增加（减少）了n乘sizeof（原指针指向的类型）个字节。

```
char a[20] = "you are a girl";
char *p = a;
char **ptr = &p; //ptr类型是char**, 指向类型是char*类型，指向地址是p的地址
ptr++; //增加一个sizeof(char*)，即&p+4，输出不确定，随机或非法操作
```

**运算符& 和 * **

&a运算结果是一个指针，指针的类型是a的类型加个*，指针所指向的类型是a的类型，指针所指向的地址就是a的地址。

*p的运算结果是p所指向的东西，*p的类型是p指向的类型，所占用的地址是p所指向的地址。

指针表达式【一个表达式的结果是指针，就是指针表达式】

指针表达式也具有指针所具有的四个要素:指针的类型,指针所指向的类型,指针指向的内存区,指针自身占据的内存。当一个指针表达式的结果指针已经明确地具有了指针自身占据的内存的话,这个指针表达式
就是一个左值,否则就不是一个左值。

-------
-------

**数组和指针的关系**

数组的数组名可以看做一个指针

```
char *str[3] = {"Hello, thisisasample", "hi,goodmorning", "helloworld"};
chars[80];
strcpy(s, str[0]); //strcpy(s, *str);
strcpy(s, str[1]); //strcpy(s, *(str+1));
strcpy(s, str[2]); //strcpy(s, *(str+2));
```

str是个三单元数组，每个单元都是一个指针，每个指针都指向一个字符串，把指针数组名str当成指针，它指向数组的第0号单元，类型是char**，指向的类型是char *。

*str也是一个指针，类型是char*，指向的类型是char，指向的地址是字符串“hello,thisisasamle”的第一个字符的地址，即‘H’的地址。

字符串相当于一个数组，在内存中以数组的形式存储，只不过字符串是一个数组常量，内容不可改变，且只能是右值，如果看成指针的话，是常量指针，也是指针常量。

str+1也是指针，指向数组的第1号单元，类型是char**，指向的类型是char*

*(str+1)也是指针，类型是char*，指向的类型是char，指向“hi,goodmorning”的第一个字符'h'

声明了一个数组 TYPE array[n],则数组名称 array 就有了两重含义:

第一,它代表整个数组,它的类型是 TYPE[n]；第二 ,它是一个常量指针,，该指针的类型是TYPE*，该指针指向的类型是 TYPE，也就是数组单元的类型，该指针指向的内存区就是数组第 0 号单元，该指针自己占有单独的内存区，注意它和数组第 0 号单元占据的内存区是不同的。该指针的值是不能修改的,即类似 array++的表达式是错误的。


